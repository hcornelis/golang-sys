// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// mkpost processes the output of cgo -godefs to
// modify the generated types. It is used to clean up
// the sys API in an architecture specific manner.
//
// mkpost is run after cgo -godefs; see README.md.
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"regexp"
)

func main() {
	// Get the OS and architecture (using GOARCH_TARGET if it exists)
	goos := os.Getenv("GOOS")
	goarch := os.Getenv("GOARCH_TARGET")
	if goarch == "" {
		goarch = os.Getenv("GOARCH")
	}
	// Check that we are using the Docker-based build system if we should be.
	if goos == "linux" {
		if os.Getenv("GOLANG_SYS_BUILD") != "docker" {
			os.Stderr.WriteString("In the Docker-based build system, mkpost should not be called directly.\n")
			os.Stderr.WriteString("See README.md\n")
			os.Exit(1)
		}
	}

	b, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		log.Fatal(err)
	}

	if goos == "aix" {
		// Replace type of Atim, Mtim and Ctim by Timespec in Stat_t
		// to avoid having both StTimespec and Timespec.
		sttimespec := regexp.MustCompile(`_Ctype_struct_st_timespec`)
		b = sttimespec.ReplaceAll(b, []byte("Timespec"))
	}

	// Intentionally export __val fields in Fsid and Sigset_t
	valRegex := regexp.MustCompile(`type (Fsid|Sigset_t) struct {(\s+)X__(bits|val)(\s+\S+\s+)}`)
	b = valRegex.ReplaceAll(b, []byte("type $1 struct {${2}Val$4}"))

	// Intentionally export __fds_bits field in FdSet
	fdSetRegex := regexp.MustCompile(`type (FdSet) struct {(\s+)X__fds_bits(\s+\S+\s+)}`)
	b = fdSetRegex.ReplaceAll(b, []byte("type $1 struct {${2}Bits$3}"))

	// Intentionally export __icmp6_filt field in icmpv6_filter
	icmpV6Regex := regexp.MustCompile(`type (ICMPv6Filter) struct {(\s+)X__icmp6_filt(\s+\S+\s+)}`)
	b = icmpV6Regex.ReplaceAll(b, []byte("type $1 struct {${2}Filt$3}"))

	// If we have empty Ptrace structs, we should delete them. Only s390x emits
	// nonempty Ptrace structs.
	ptraceRexexp := regexp.MustCompile(`type Ptrace((Psw|Fpregs|Per) struct {\s*})`)
	b = ptraceRexexp.ReplaceAll(b, nil)

	// Replace the control_regs union with a blank identifier for now.
	controlRegsRegex := regexp.MustCompile(`(Control_regs)\s+\[0\]uint64`)
	b = controlRegsRegex.ReplaceAll(b, []byte("_ [0]uint64"))

	// Remove fields that are added by glibc
	// Note that this is unstable as the identifers are private.
	removeFieldsRegex := regexp.MustCompile(`X__glibc\S*`)
	b = removeFieldsRegex.ReplaceAll(b, []byte("_"))

	// Convert [65]int8 to [65]byte in Utsname members to simplify
	// conversion to string; see golang.org/issue/20753
	convertUtsnameRegex := regexp.MustCompile(`((Sys|Node|Domain)name|Release|Version|Machine)(\s+)\[(\d+)\]u?int8`)
	b = convertUtsnameRegex.ReplaceAll(b, []byte("$1$3[$4]byte"))

	// Convert [n]int8 to [n]byte in Statvfs_t members to simplify
	// conversion to string.
	convertStatvfsRegex := regexp.MustCompile(`((Fstype|Mnton|Mntfrom)name)(\s+)\[(\d+)\]int8`)
	b = convertStatvfsRegex.ReplaceAll(b, []byte("$1$3[$4]byte"))

	// Convert []int8 to []byte in device mapper ioctl interface
	convertDmIoctlNames := regexp.MustCompile(`(Name|Uuid|Target_type|Data)(\s+)\[(\d+)\]u?int8`)
	dmIoctlTypes := regexp.MustCompile(`type Dm(\S+) struct {[^}]*}`)
	dmStructs := dmIoctlTypes.FindAll(b, -1)
	for _, s := range dmStructs {
		newNames := convertDmIoctlNames.ReplaceAll(s, []byte("$1$2[$3]byte"))
		b = bytes.Replace(b, s, newNames, 1)
	}

	// Convert []int8 to []byte in ctl_info ioctl interface
	convertCtlInfoName := regexp.MustCompile(`(Name)(\s+)\[(\d+)\]int8`)
	ctlInfoType := regexp.MustCompile(`type CtlInfo struct {[^}]*}`)
	ctlInfoStructs := ctlInfoType.FindAll(b, -1)
	for _, s := range ctlInfoStructs {
		newNames := convertCtlInfoName.ReplaceAll(s, []byte("$1$2[$3]byte"))
		b = bytes.Replace(b, s, newNames, 1)
	}

	// Convert [1024]int8 to [1024]byte in Ptmget members
	convertPtmget := regexp.MustCompile(`([SC]n)(\s+)\[(\d+)\]u?int8`)
	b = convertPtmget.ReplaceAll(b, []byte("$1[$3]byte"))

	// Remove spare fields (e.g. in Statx_t)
	spareFieldsRegex := regexp.MustCompile(`X__spare\S*`)
	b = spareFieldsRegex.ReplaceAll(b, []byte("_"))

	// Remove cgo padding fields
	removePaddingFieldsRegex := regexp.MustCompile(`Pad_cgo_\d+`)
	b = removePaddingFieldsRegex.ReplaceAll(b, []byte("_"))

	// Remove padding, hidden, or unused fields
	removeFieldsRegex = regexp.MustCompile(`\b(X_\S+|Padding)`)
	b = removeFieldsRegex.ReplaceAll(b, []byte("_"))

	// Remove the first line of warning from cgo
	b = b[bytes.IndexByte(b, '\n')+1:]
	// Modify the command in the header to include:
	//  mkpost, our own warning, and a build tag.
	replacement := fmt.Sprintf(`$1 | go run mkpost.go
// Code generated by the command above; see README.md. DO NOT EDIT.

// +build %s,%s`, goarch, goos)
	cgoCommandRegex := regexp.MustCompile(`(cgo -godefs .*)`)
	b = cgoCommandRegex.ReplaceAll(b, []byte(replacement))

	// Rename Stat_t time fields
	if goos == "freebsd" && goarch == "386" {
		// Hide Stat_t.[AMCB]tim_ext fields
		renameStatTimeExtFieldsRegex := regexp.MustCompile(`[AMCB]tim_ext`)
		b = renameStatTimeExtFieldsRegex.ReplaceAll(b, []byte("_"))
	}
	renameStatTimeFieldsRegex := regexp.MustCompile(`([AMCB])(?:irth)?time?(?:spec)?\s+(Timespec|StTimespec)`)
	b = renameStatTimeFieldsRegex.ReplaceAll(b, []byte("${1}tim ${2}"))

	// Retype the Statfs_t fields on ppc to uints
	if goos == "linux" && goarch == "ppc" {
		// retype ppc Statfs_t fields

		renameStatFSPPCFieldsRegex1 := regexp.MustCompile(`type Statfs_t struct {
(\s+)Type(\s+)int32
(\s+)Bsize(\s+)int32`)
		b = renameStatFSPPCFieldsRegex1.ReplaceAll(b, []byte(`type Statfs_t struct {
${1}Type${2}uint32
${3}Bsize${4}uint32`))

		renameStatFSPPCFieldsRegex2 := regexp.MustCompile(`(\s+)Namelen(\s+)int32
(\s+)Frsize(\s+)int32
(\s+)Flags(\s+)int32
(\s+)Spare(\s+)\[4\]int32
(\s+)_(\s+)\[4\]byte`)
		b = renameStatFSPPCFieldsRegex2.ReplaceAll(b, []byte(`${1}Namelen${2}uint32
${3}Frsize${4}uint32
${5}Flags${6}uint32
${7}Spare${8}[4]uint32
${9}_${10}[4]byte`))
	}

	// Correct 64 bit alignment of the EpollEvent struct on ppc
	if goos == "linux" && goarch == "ppc" {
		// retype ppc EpollEvent fields

		renameStatFSPPCFieldsRegex1 := regexp.MustCompile(`type EpollEvent struct {
(\s+)Events(\s+)uint32
(\s+)Fd(\s+)int32`)
		b = renameStatFSPPCFieldsRegex1.ReplaceAll(b, []byte(`type EpollEvent struct {
${1}Events${2}uint32
	_      uint32
${3}Fd${4}int32`))

	}

	// gofmt
	b, err = format.Source(b)
	if err != nil {
		log.Fatal(err)
	}

	os.Stdout.Write(b)
}
